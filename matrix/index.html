<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <link rel="preload" href="./fonts/MatrixCodeNFI.ttf" as="font" type="font/ttf" crossorigin="anonymous">
    <title>Matrix Rain Effect with Noise and CRT</title>
    <style>
        @font-face {
            font-family: 'Matrix Code';
            src: url('./fonts/MatrixCodeNFI.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        * {
            margin: 0;
            padding: 0;
            border: 0;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100vh;
            overflow: hidden;
            overscroll-behavior-y: none;
            box-sizing: border-box;
            line-height: 1;
        }

        body {
            background-color: #000;
            font-family: 'Matrix Code', 'Courier New', monospace;
            font-weight: 700;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            margin: 0;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
        }

        #crt-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(circle at center,
                    transparent 38.2%,
                    rgba(0, 0, 0, 0.618) 100%),
                url('assets/RGB.png');
            background-repeat: repeat;
            background-blend-mode: multiply;
            image-rendering: pixelated;
            z-index: 10;
        }

        #bayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: url('assets/bayer8.png');
            background-repeat: repeat;
            mix-blend-mode: overlay;
            image-rendering: pixelated;
            opacity: 0.25;
            z-index: 11;
        }

        #fullscreen-button {
            margin: 0;
            padding: 0;
            line-height: 0;
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 24px 12px;
            background: rgba(0, 0, 0, 0.5);
            font-size: 12px;
            color: white;
            border: none;
            border-radius: 10%;
            cursor: pointer;
            z-index: 100;
            font-size: 25px;
            transition: opacity 0.5s ease;
        }

        #fullscreen-button:hover {
            background: #001608;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        .cursor-hidden {
            cursor: none;
        }
    </style>
</head>

<body>
    <canvas id="matrix"></canvas>
    <div id="bayer"></div>
    <div id="crt-overlay"></div>
    <button id="fullscreen-button" class="hidden" title="Toggle fullscreen">⛶</button>
    <script>



        // ===== ПАРАМЕТРЫ ЭФФЕКТА =====
        const CONFIG = {
            // Символы
            katakana: 'アァカサタナハマヤャラワガザダバパイィキシチニヒミリヰギジヂビピウゥクスツヌフムユュルグズブヅプエェケセテネヘメレヱゲゼデベペオォコソトノホモヨョロヲゴゾドボポヴッン',
            latin: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
            nums: '0123456789',
            symbols: '!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~',
            // Настройки отображения
            fontSize: 16,
            verticalSpacing: 1, // Множитель для вертикального отступа (1.0 = без отступа)
            trailOpacity: 0.1, // Прозрачность следа
            frameRate: 24, // Интервал между кадрами в мс (~30 FPS)
            // Цвета
            headColor: '#06FF32',      // Основной цвет (ярко-зеленый)
            mainColor: '#03A032',     // Цвет первого символа (зеленый)
            trailColor: '#013B04',    // Цвет трейла
            fadeColor: '#001122',     // Цвет затухания
            flickerColor: '#FFFFFF',  // Цвет мерцания
            glowRadius: 5,           // Радиус свечения
            glowIntensity: 0.75,       // Интенсивность свечения
            // Настройки анимации
            speed: 1,               // Базовая скорость падения
            randomResetThreshold: 0.5, // Порог случайного сброса капли
            initialYOffset: 128,    // Начальное смещение капель за верхней границей
            trailLength: 32,         // Максимальная длина трейла
            // Настройки мерцания
            flicker: {
                minDelay: 25,    // минимальная задержка между мерцаниями (мс)
                maxDelay: 500,   // максимальная задержка между мерцаниями
                duration: 75,   // длительность мерцания (мс)
                chance: 0.05     // вероятность мерцания
            }
        };
        CONFIG.flickerBackground = {
            color: `rgba(50, 200, 200, 0.382)` // Полупрозрачный зеленоватый
        };
        // FPS Control
        let lastTime = 0;
        const targetFrameTime = 1000 / CONFIG.frameRate;

        const canvas = document.getElementById('matrix');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        ctx.mozImageSmoothingEnabled = false;
        ctx.webkitImageSmoothingEnabled = false;
        // Устанавливаем размер canvas на весь экран
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Объединяем все символы
        const alphabet = CONFIG.katakana + CONFIG.nums + CONFIG.symbols; // CONFIG.latin + 

        // Количество колонок
        let columns = Math.round(canvas.width / CONFIG.fontSize);

        // Массив для хранения позиции Y каждой капли
        const drops = [];
        // Массив для хранения длины каждой цепочки
        const chainLengths = [];
        // Массив для хранения предыдущих символов (для трейла)
        const trails = [];
        // Массив для хранения состояния мерцания
        const flickers = [];
        // Инициализируем капли
        for (let i = 0; i < columns; i++) {
            drops[i] = Math.random() * -CONFIG.initialYOffset;
            chainLengths[i] = Math.round(Math.random() * 15) + 5;
            trails[i] = [];
            flickers[i] = {
                active: false,
                nextFlicker: Date.now() + CONFIG.flicker.minDelay + Math.random() * CONFIG.flicker.maxDelay,
                endTime: 0
            };
        }

        // Функция для создания эффекта свечения
        function drawGlow(x, y, text, isFlickering) {
            const { color } = CONFIG.flickerBackground;
            const charWidth = ctx.measureText(text).width;
            const charHeight = CONFIG.fontSize;

            // Сохраняем текущие настройки контекста
            ctx.save();

            if (isFlickering) {
                ctx.fillStyle = color;
                ctx.fillRect(x - CONFIG.fontSize/2, y - CONFIG.fontSize/2, charWidth, charHeight);
            }

            // Устанавливаем параметры свечения
            ctx.shadowColor = `rgba(30,230,0,0.05)`;
            ctx.shadowBlur = CONFIG.glowRadius;
            ctx.fillStyle = getSymbolColor(0, isFlickering);
            ctx.fillText(text, x, y);

            // Восстанавливаем настройки контекста
            ctx.restore();
        }

        // Функция для определения цвета и прозрачности символа в зависимости от его позиции в цепочке
        function getSymbolColor(position, isFlickering) {
            let brightness;
            if (position === 0) {
                brightness = 100; // Голова
            } else if (position < 3) {
                brightness = 90 - position * 10;
            } else {
                brightness = Math.max(10, 50 - position * 2);
            }
            brightness = 100 - brightness;

            // Выбираем цвет
            let color;
            if (position === 0 && isFlickering) {
                return CONFIG.flickerColor + 'FF';
            } else if (brightness > 80) {
                color = CONFIG.headColor;
            } else if (brightness > 50) {
                color = CONFIG.mainColor;
            } else if (brightness > 20) {
                color = CONFIG.trailColor;
            } else {
                color = CONFIG.fadeColor;
            }

            // Прозрачность
            const alpha = Math.min(1, brightness / 100);
            return color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
        }

        // Функция рисования
        function draw(timestamp) {
            if (!lastTime || timestamp - lastTime >= targetFrameTime) {
                lastTime = timestamp;
                const now = Date.now();

                // Предварительные вычисления констант
                const fontSize = CONFIG.fontSize;
                const vSpacing = CONFIG.verticalSpacing;
                const canvasHeight = canvas.height;
                const trailOpacity = CONFIG.trailOpacity;
                const randomResetThreshold = CONFIG.randomResetThreshold;
                const speed = CONFIG.speed;

                // Очищаем canvas
                ctx.fillStyle = `rgba(0, 0, 0, ${trailOpacity})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Устанавливаем шрифт один раз
                ctx.font = `bold ${fontSize}px 'Matrix Code', monospace`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Оптимизация: заранее вычисляем длину массива
                const dropsCount = drops.length;

                for (let i = 0; i < dropsCount; i++) {
                    // Оптимизированная обработка мерцания
                    const flicker = flickers[i];
                    if (!flicker.active && now > flicker.nextFlicker && Math.random() < CONFIG.flicker.chance) {
                        flicker.active = true;
                        flicker.endTime = now + CONFIG.flicker.duration;
                    } else if (flicker.active && now > flicker.endTime) {
                        flicker.active = false;
                        flicker.nextFlicker = now + CONFIG.flicker.minDelay + Math.random() * CONFIG.flicker.maxDelay;
                    }

                    // Используем битовые операции для целочисленного деления
                    const positionInChain = Math.round(drops[i]) % chainLengths[i] | 0;
                    const text = alphabet.charAt(Math.random() * alphabet.length | 0);
                    const x = i * fontSize;
                    const y = drops[i] * fontSize * vSpacing;

                    // Оптимизация работы с массивом трейла
                    const trail = trails[i];
                    trail.unshift({ text, x, y, positionInChain });
                    if (trail.length > CONFIG.trailLength) {
                        trail.pop();
                    }

                    // Рисуем трейл (обратный порядок для правильного наложения)
                    const trailLength = trail.length;
                    for (let j = trailLength - 1; j > 0; j--) {
                        const item = trail[j];
                        ctx.fillStyle = getSymbolColor(item.positionInChain, false);
                        ctx.fillText(item.text, item.x, item.y);
                    }

                    // Рисуем головной символ
                    if (positionInChain === 0) {
                        const yPos = y;
                        if (yPos >= -fontSize && yPos < canvasHeight) {
                            drawGlow(x, yPos, text, flicker.active);
                            ctx.fillStyle = getSymbolColor(0, flicker.active);
                            ctx.fillText(text, x, yPos);
                        }
                    }

                    // Оптимизированный сброс капли
                    if (drops[i] * fontSize > canvasHeight + fontSize && Math.random() > randomResetThreshold) {
                        drops[i] = 0;
                        chainLengths[i] = (Math.random() * 15 | 0);
                        trails[i] = [];
                        flickers[i] = {
                            active: false,
                            nextFlicker: now + CONFIG.flicker.minDelay + Math.random() * CONFIG.flicker.maxDelay,
                            endTime: 0
                        };
                    }
                    drops[i] += speed;
                }
            }
            requestAnimationFrame(draw);
        }

        // Обработчик изменения размера окна
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            columns = Math.round(canvas.width / CONFIG.fontSize);
        };

        // Таймеры для управления скрытием элементов
        let hideTimeout;

        // Создаем кнопку полноэкранного режима
        function FullscreenButton() {
            const btn = document.getElementById('fullscreen-button');
            btn.onclick = toggleFullscreen;
            resetHideTimers(); // Запускаем таймеры скрытия
        }
        // Функция для переключения полноэкранного режима
        function toggleFullscreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else document.exitFullscreen();
            resetHideTimers(); // Сброс таймеров при взаимодействии
        }
        // Сброс таймеров скрытия
        function resetHideTimers() {
            const btn = document.getElementById('fullscreen-button');
            if (btn) btn.classList.remove('hidden');
            document.body.classList.remove('cursor-hidden');

            // Очищаем предыдущие таймеры
            clearTimeout(hideTimeout);
            // Устанавливаем новые таймеры
            hideTimeout = setTimeout(() => {
                document.getElementById('fullscreen-button').classList.add('hidden');
                document.body.classList.add('cursor-hidden');
            }, 1000);
        }
        // Инициализация при загрузке

        document.addEventListener('DOMContentLoaded', () => {
            FullscreenButton();
            // Add event listeners
            const events = ['mousemove', 'mousedown', 'keydown', 'touchstart', 'scroll'];
            events.forEach(event => {
                document.addEventListener(event, resetHideTimers);
            });
            window.addEventListener('resize', resizeCanvas);
            // Start animation
            requestAnimationFrame(draw);
        });


    </script>
</body>

</html>